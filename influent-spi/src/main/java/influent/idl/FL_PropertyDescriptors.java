/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
package influent.idl;  
@SuppressWarnings("all")
/** * An instance of PropertyDescriptors is used to contain the dataset-specific type and property descriptions returned
	 * by getDescriptors()
	 *
	 * ADDED IN 1.8 */
@org.apache.avro.specific.AvroGenerated
public class FL_PropertyDescriptors extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"FL_PropertyDescriptors\",\"namespace\":\"influent.idl\",\"doc\":\"* An instance of PropertyDescriptors is used to contain the dataset-specific type and property descriptions returned\\n\\t * by getDescriptors()\\n\\t *\\n\\t * ADDED IN 1.8\",\"fields\":[{\"name\":\"searchHint\",\"type\":[\"null\",{\"type\":\"string\",\"avro.java.string\":\"String\"}],\"default\":null},{\"name\":\"properties\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"FL_PropertyDescriptor\",\"doc\":\"* Used to describe data properties and their constraints\\n\\t *\\n\\t * The 'memberOf' parameter is a list of FL_TypeMapping that describes the property in the given types.\\n\\t *\\n\\t * ADDED IN 1.8\",\"fields\":[{\"name\":\"key\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"doc\":\"property descriptor unique key\"},{\"name\":\"friendlyText\",\"type\":[\"null\",{\"type\":\"string\",\"avro.java.string\":\"String\"}],\"doc\":\"a human readable property name to display if the key isn't friendly (optional)\",\"default\":null},{\"name\":\"propertyType\",\"type\":{\"type\":\"enum\",\"name\":\"FL_PropertyType\",\"doc\":\"* Allowed types for Property values.\\n\\t *\\n\\t * CHANGED in 1.9\",\"symbols\":[\"FLOAT\",\"DOUBLE\",\"INTEGER\",\"LONG\",\"BOOLEAN\",\"STRING\",\"IMAGE\",\"DATE\",\"GEO\"]},\"doc\":\"data type of the property\"},{\"name\":\"range\",\"type\":[{\"type\":\"enum\",\"name\":\"FL_RangeType\",\"doc\":\"* Allowed types for Ranges of values.\\n\\t *\\n\\t * CHANGED IN 1.6\",\"symbols\":[\"SINGLETON\",\"LIST\",\"BOUNDED\",\"DISTRIBUTION\"]},\"null\"],\"doc\":\"range of the Property to search on\"},{\"name\":\"memberOf\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"FL_TypeMapping\",\"doc\":\"* Used to describe how an FL_PropertyDescriptor maps to given a type.\\n\\t *\\n\\t * ADDED IN 1.8\",\"fields\":[{\"name\":\"type\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"doc\":\"The type that the mapping applies to *\"},{\"name\":\"memberKey\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"doc\":\"field that the FL_Property maps to in the type *\"}]}},\"doc\":\"List of mappings against types to which this property belongs,  *\"},{\"name\":\"constraint\",\"type\":[{\"type\":\"enum\",\"name\":\"FL_Constraint\",\"doc\":\"* Property value matching constraints\\n\\t *\\n\\t * ADDED IN 1.5\\n\\t * MOVED IN 2.0\",\"symbols\":[\"REQUIRED_EQUALS\",\"FUZZY_PARTIAL_OPTIONAL\",\"NOT\",\"OPTIONAL_EQUALS\",\"FUZZY_REQUIRED\"]},\"null\"],\"doc\":\"REQUIRED_EQUALS, FUZZY_PARTIAL_OPTIONAL, NOT, OPTIONAL_EQUALS, FUZZY_REQUIRED\"},{\"name\":\"searchableBy\",\"type\":{\"type\":\"enum\",\"name\":\"FL_SearchableBy\",\"doc\":\"* Used to describe in which contexts a term can (or should) be searched. Free text searches\\n\\t * do not describe properties to which they apply, and are often best restricted to\\n\\t * identity fields like names.\\n\\t *\\n\\t * ADDED IN 1.8\\n\\t * MOVED IN 2.0\",\"symbols\":[\"FREE_TEXT\",\"DESCRIPTOR\",\"NONE\"]},\"doc\":\"indicates whether this property is indexed for free text queries, or not at all *\",\"default\":\"DESCRIPTOR\"},{\"name\":\"levelOfDetail\",\"type\":{\"type\":\"enum\",\"name\":\"FL_LevelOfDetail\",\"doc\":\"* Amount of detail requested\\n\\t *\\n\\t * ADDED IN 1.6\\n\\t *\\n\\t * CHANGED in 2.0:\\n\\t * - added KEY\",\"symbols\":[\"KEY\",\"SUMMARY\",\"FULL\",\"HIDDEN\"]},\"doc\":\"Minimum amount of detail that this property is included in *\",\"default\":\"FULL\"},{\"name\":\"tags\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"enum\",\"name\":\"FL_PropertyTag\",\"doc\":\"* Tags are defined by the application layer as a taxonomy of user and application concepts,\\n\\t * independent of the data sources. This allows application semantics to be re-used with new\\n\\t * data, with a minimum of new software design and development. Data layer entity types, link\\n\\t * types and properties should be mapped into the list of tags. The application layer must be\\n\\t * able to search by native field name or by tag interchangeably, and properties returned must\\n\\t * contain both native field names as well as tags.\\n\\t *\\n\\t * The list of tags may change as application features evolve, though that will require\\n\\t * collaboration with the data layer providers. Evolving the tag list should not change the\\n\\t * Data Access or Search APIs.\\n\\t *\\n\\t * This is the current list of tags for Properties:\\n\\t *\\n\\t * CHANGED in 1.5:\\n\\t * - CREDIT/DEBIT changed to INFLOWING/OUTFLOWING\\n\\t * - added USD\\n\\t * - added DURATION\\n\\t *\\n\\t * CHANGED in 1.6:\\n\\t * - added ENTITY_TYPE\\n\\t * - added ACCOUNT_OWNER, CLUSTER_SUMMARY, COUNTRY_CODE\\n\\t *\\n\\t * CHANGED in 1.7:\\n\\t * - added CLUSTER\\n\\t *\\n\\t * CHANGED in 1.8:\\n\\t * - added TOPIC\\n\\t *\\n\\t * CHANGED in 1.9:\\n\\t * - added HTML\\n\\t *\\n\\t * CHANGED in 2.0:\\n\\t * - added UNITS\\n\\t * - added FROM_LABEL\\n\\t * - added TO_LABEL\",\"symbols\":[\"ID\",\"TYPE\",\"ENTITY_TYPE\",\"ACCOUNT_OWNER\",\"CLUSTER_SUMMARY\",\"CLUSTER\",\"NAME\",\"LABEL\",\"STAT\",\"TEXT\",\"HTML\",\"TOPIC\",\"STATUS\",\"ANNOTATION\",\"WARNING\",\"LINKED_DATA\",\"GEO\",\"COUNTRY_CODE\",\"DATE\",\"AMOUNT\",\"INFLOWING\",\"OUTFLOWING\",\"COUNT\",\"SERIES\",\"CONSTRUCTED\",\"RAW\",\"UNITS\",\"USD\",\"DURATION\",\"ENTITY\",\"SHARED_IDENTIFIER\",\"FROM_LABEL\",\"TO_LABEL\"]}},\"doc\":\"List of tags that belong to this property *\"},{\"name\":\"sortable\",\"type\":\"boolean\",\"doc\":\"indicates whether this property can be used to sort *\",\"default\":true},{\"name\":\"multiValue\",\"type\":\"boolean\",\"doc\":\"indicates whether this property can have multiple values *\",\"default\":false}]}},\"default\":null},{\"name\":\"types\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"FL_TypeDescriptor\",\"doc\":\"* Used to describe applicable types for a searchable property. Types may be grouped with the 'group' parameter.\\n\\t *\\n\\t * ADDED IN 1.8\",\"fields\":[{\"name\":\"key\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"doc\":\"unique key of the type descriptor applicable to a property *\"},{\"name\":\"friendlyText\",\"type\":[\"null\",{\"type\":\"string\",\"avro.java.string\":\"String\"}],\"doc\":\"a human readable type name to display if the key isn't friendly (optional)\",\"default\":null},{\"name\":\"group\",\"type\":[\"null\",{\"type\":\"string\",\"avro.java.string\":\"String\"}],\"doc\":\"Group name (optional) *\",\"default\":null},{\"name\":\"exclusive\",\"type\":\"boolean\",\"doc\":\"Indicates whether searching within the defined group is exclusive *\",\"default\":true},{\"name\":\"namespace\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"doc\":\"the namespace the type is linked to *\"}]}},\"default\":null},{\"name\":\"orderBy\",\"type\":[\"null\",{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"FL_OrderBy\",\"doc\":\"* Ordering instructions for records, as specified in search requests.\\n\\t *\\n\\t * ADDED IN 2.0\",\"fields\":[{\"name\":\"propertyKey\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"doc\":\"The key of the property value to order by\"},{\"name\":\"ascending\",\"type\":\"boolean\",\"doc\":\"ascending? (or descending)\",\"default\":false}]}}],\"default\":null},{\"name\":\"groupField\",\"type\":[\"null\",{\"type\":\"string\",\"avro.java.string\":\"String\"}],\"default\":null}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
   private java.lang.String searchHint;
   private java.util.List<influent.idl.FL_PropertyDescriptor> properties;
   private java.util.List<influent.idl.FL_TypeDescriptor> types;
   private java.util.List<influent.idl.FL_OrderBy> orderBy;
   private java.lang.String groupField;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use {@link \#newBuilder()}. 
   */
  public FL_PropertyDescriptors() {}

  /**
   * All-args constructor.
   */
  public FL_PropertyDescriptors(java.lang.String searchHint, java.util.List<influent.idl.FL_PropertyDescriptor> properties, java.util.List<influent.idl.FL_TypeDescriptor> types, java.util.List<influent.idl.FL_OrderBy> orderBy, java.lang.String groupField) {
    this.searchHint = searchHint;
    this.properties = properties;
    this.types = types;
    this.orderBy = orderBy;
    this.groupField = groupField;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call. 
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return searchHint;
    case 1: return properties;
    case 2: return types;
    case 3: return orderBy;
    case 4: return groupField;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
  // Used by DatumReader.  Applications should not call. 
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: searchHint = (java.lang.String)value$; break;
    case 1: properties = (java.util.List<influent.idl.FL_PropertyDescriptor>)value$; break;
    case 2: types = (java.util.List<influent.idl.FL_TypeDescriptor>)value$; break;
    case 3: orderBy = (java.util.List<influent.idl.FL_OrderBy>)value$; break;
    case 4: groupField = (java.lang.String)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'searchHint' field.
   */
  public java.lang.String getSearchHint() {
    return searchHint;
  }

  /**
   * Sets the value of the 'searchHint' field.
   * @param value the value to set.
   */
  public void setSearchHint(java.lang.String value) {
    this.searchHint = value;
  }

  /**
   * Gets the value of the 'properties' field.
   */
  public java.util.List<influent.idl.FL_PropertyDescriptor> getProperties() {
    return properties;
  }

  /**
   * Sets the value of the 'properties' field.
   * @param value the value to set.
   */
  public void setProperties(java.util.List<influent.idl.FL_PropertyDescriptor> value) {
    this.properties = value;
  }

  /**
   * Gets the value of the 'types' field.
   */
  public java.util.List<influent.idl.FL_TypeDescriptor> getTypes() {
    return types;
  }

  /**
   * Sets the value of the 'types' field.
   * @param value the value to set.
   */
  public void setTypes(java.util.List<influent.idl.FL_TypeDescriptor> value) {
    this.types = value;
  }

  /**
   * Gets the value of the 'orderBy' field.
   */
  public java.util.List<influent.idl.FL_OrderBy> getOrderBy() {
    return orderBy;
  }

  /**
   * Sets the value of the 'orderBy' field.
   * @param value the value to set.
   */
  public void setOrderBy(java.util.List<influent.idl.FL_OrderBy> value) {
    this.orderBy = value;
  }

  /**
   * Gets the value of the 'groupField' field.
   */
  public java.lang.String getGroupField() {
    return groupField;
  }

  /**
   * Sets the value of the 'groupField' field.
   * @param value the value to set.
   */
  public void setGroupField(java.lang.String value) {
    this.groupField = value;
  }

  /** Creates a new FL_PropertyDescriptors RecordBuilder */
  public static influent.idl.FL_PropertyDescriptors.Builder newBuilder() {
    return new influent.idl.FL_PropertyDescriptors.Builder();
  }
  
  /** Creates a new FL_PropertyDescriptors RecordBuilder by copying an existing Builder */
  public static influent.idl.FL_PropertyDescriptors.Builder newBuilder(influent.idl.FL_PropertyDescriptors.Builder other) {
    return new influent.idl.FL_PropertyDescriptors.Builder(other);
  }
  
  /** Creates a new FL_PropertyDescriptors RecordBuilder by copying an existing FL_PropertyDescriptors instance */
  public static influent.idl.FL_PropertyDescriptors.Builder newBuilder(influent.idl.FL_PropertyDescriptors other) {
    return new influent.idl.FL_PropertyDescriptors.Builder(other);
  }
  
  /**
   * RecordBuilder for FL_PropertyDescriptors instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<FL_PropertyDescriptors>
    implements org.apache.avro.data.RecordBuilder<FL_PropertyDescriptors> {

    private java.lang.String searchHint;
    private java.util.List<influent.idl.FL_PropertyDescriptor> properties;
    private java.util.List<influent.idl.FL_TypeDescriptor> types;
    private java.util.List<influent.idl.FL_OrderBy> orderBy;
    private java.lang.String groupField;

    /** Creates a new Builder */
    private Builder() {
      super(influent.idl.FL_PropertyDescriptors.SCHEMA$);
    }
    
    /** Creates a Builder by copying an existing Builder */
    private Builder(influent.idl.FL_PropertyDescriptors.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.searchHint)) {
        this.searchHint = data().deepCopy(fields()[0].schema(), other.searchHint);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.properties)) {
        this.properties = data().deepCopy(fields()[1].schema(), other.properties);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.types)) {
        this.types = data().deepCopy(fields()[2].schema(), other.types);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.orderBy)) {
        this.orderBy = data().deepCopy(fields()[3].schema(), other.orderBy);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.groupField)) {
        this.groupField = data().deepCopy(fields()[4].schema(), other.groupField);
        fieldSetFlags()[4] = true;
      }
    }
    
    /** Creates a Builder by copying an existing FL_PropertyDescriptors instance */
    private Builder(influent.idl.FL_PropertyDescriptors other) {
            super(influent.idl.FL_PropertyDescriptors.SCHEMA$);
      if (isValidValue(fields()[0], other.searchHint)) {
        this.searchHint = data().deepCopy(fields()[0].schema(), other.searchHint);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.properties)) {
        this.properties = data().deepCopy(fields()[1].schema(), other.properties);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.types)) {
        this.types = data().deepCopy(fields()[2].schema(), other.types);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.orderBy)) {
        this.orderBy = data().deepCopy(fields()[3].schema(), other.orderBy);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.groupField)) {
        this.groupField = data().deepCopy(fields()[4].schema(), other.groupField);
        fieldSetFlags()[4] = true;
      }
    }

    /** Gets the value of the 'searchHint' field */
    public java.lang.String getSearchHint() {
      return searchHint;
    }
    
    /** Sets the value of the 'searchHint' field */
    public influent.idl.FL_PropertyDescriptors.Builder setSearchHint(java.lang.String value) {
      validate(fields()[0], value);
      this.searchHint = value;
      fieldSetFlags()[0] = true;
      return this; 
    }
    
    /** Checks whether the 'searchHint' field has been set */
    public boolean hasSearchHint() {
      return fieldSetFlags()[0];
    }
    
    /** Clears the value of the 'searchHint' field */
    public influent.idl.FL_PropertyDescriptors.Builder clearSearchHint() {
      searchHint = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /** Gets the value of the 'properties' field */
    public java.util.List<influent.idl.FL_PropertyDescriptor> getProperties() {
      return properties;
    }
    
    /** Sets the value of the 'properties' field */
    public influent.idl.FL_PropertyDescriptors.Builder setProperties(java.util.List<influent.idl.FL_PropertyDescriptor> value) {
      validate(fields()[1], value);
      this.properties = value;
      fieldSetFlags()[1] = true;
      return this; 
    }
    
    /** Checks whether the 'properties' field has been set */
    public boolean hasProperties() {
      return fieldSetFlags()[1];
    }
    
    /** Clears the value of the 'properties' field */
    public influent.idl.FL_PropertyDescriptors.Builder clearProperties() {
      properties = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /** Gets the value of the 'types' field */
    public java.util.List<influent.idl.FL_TypeDescriptor> getTypes() {
      return types;
    }
    
    /** Sets the value of the 'types' field */
    public influent.idl.FL_PropertyDescriptors.Builder setTypes(java.util.List<influent.idl.FL_TypeDescriptor> value) {
      validate(fields()[2], value);
      this.types = value;
      fieldSetFlags()[2] = true;
      return this; 
    }
    
    /** Checks whether the 'types' field has been set */
    public boolean hasTypes() {
      return fieldSetFlags()[2];
    }
    
    /** Clears the value of the 'types' field */
    public influent.idl.FL_PropertyDescriptors.Builder clearTypes() {
      types = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /** Gets the value of the 'orderBy' field */
    public java.util.List<influent.idl.FL_OrderBy> getOrderBy() {
      return orderBy;
    }
    
    /** Sets the value of the 'orderBy' field */
    public influent.idl.FL_PropertyDescriptors.Builder setOrderBy(java.util.List<influent.idl.FL_OrderBy> value) {
      validate(fields()[3], value);
      this.orderBy = value;
      fieldSetFlags()[3] = true;
      return this; 
    }
    
    /** Checks whether the 'orderBy' field has been set */
    public boolean hasOrderBy() {
      return fieldSetFlags()[3];
    }
    
    /** Clears the value of the 'orderBy' field */
    public influent.idl.FL_PropertyDescriptors.Builder clearOrderBy() {
      orderBy = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /** Gets the value of the 'groupField' field */
    public java.lang.String getGroupField() {
      return groupField;
    }
    
    /** Sets the value of the 'groupField' field */
    public influent.idl.FL_PropertyDescriptors.Builder setGroupField(java.lang.String value) {
      validate(fields()[4], value);
      this.groupField = value;
      fieldSetFlags()[4] = true;
      return this; 
    }
    
    /** Checks whether the 'groupField' field has been set */
    public boolean hasGroupField() {
      return fieldSetFlags()[4];
    }
    
    /** Clears the value of the 'groupField' field */
    public influent.idl.FL_PropertyDescriptors.Builder clearGroupField() {
      groupField = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    @Override
    public FL_PropertyDescriptors build() {
      try {
        FL_PropertyDescriptors record = new FL_PropertyDescriptors();
        record.searchHint = fieldSetFlags()[0] ? this.searchHint : (java.lang.String) defaultValue(fields()[0]);
        record.properties = fieldSetFlags()[1] ? this.properties : (java.util.List<influent.idl.FL_PropertyDescriptor>) defaultValue(fields()[1]);
        record.types = fieldSetFlags()[2] ? this.types : (java.util.List<influent.idl.FL_TypeDescriptor>) defaultValue(fields()[2]);
        record.orderBy = fieldSetFlags()[3] ? this.orderBy : (java.util.List<influent.idl.FL_OrderBy>) defaultValue(fields()[3]);
        record.groupField = fieldSetFlags()[4] ? this.groupField : (java.lang.String) defaultValue(fields()[4]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }
}
